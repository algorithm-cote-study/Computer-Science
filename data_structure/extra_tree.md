## Q. RedBlackTree
<details>
    <summary>Q. RedBlackTree란 ?</summary>
    <div markdown="1">
        
        이진 트리는 일반적으로 어떤 노드를 선택하든 그 노드를 중심으로 왼쪽은 작은 값, 오른쪽은 큰 값이 들어가는 자료구조입니다.

        하지만 한쪽으로 쏠리게 되는 경우 최악의 경우로 O(n) 의 시간 복잡도가 발생하게 되는데, 
        이를 개선하기 위해 항상 트리가 균형을 이루게끔 만들어 진 것이 레드블랙 트리 입니다.

        레드 블랙 트리의 조건은 다음과 같습니다.

        1. 루트 노드는 무조건 검은색이다.
        2. 신규 노드는 무조건 빨간색이다.
        3. 빨간색 노드 다음엔 무조건 검은색 노드여야 한다. ( 빨간색 중복 방지 )
        4. 마지막 노드들로 부터 루트 노드까지 가면서 만나는 검은색 노드는 그 수가 모두 같다 (노드 수는 다를 수 있음)

        여기서 신규 노드가 들어올 경우 무조건 빨간색으로 들어오게 되는데, 이 경우 마지막 이전에 들어갔던 노드도 빨간색이기 때문에 3번 항목에 위배 됩니다.

        이를 해결하고자 레드 블랙 트리는 2가지 방법을 제공합니다. 

        정렬에 따라 제일 아래에 위치한 노드를 기준으로 부모의 형제가 2가지 방법 중 택일을 할 수 있는 키 값이 됩니다.

        만약 부모의 형제가 검은색일 경우 Restructuring을 하게 됩니다.

        Restructuring은 방금 말한 부모의 형제를 제외한 부모와 자식, 부모의 부모까지 3개의 노드를 정렬하는 방법입니다.

        3개의 노드를 정렬한 이후 가장 위의 노드를 검은색으로 만들고 정렬을 한 뒤 자식들을 모두 빨간색으로 만드는 방법입니다.

<img src="https://user-images.githubusercontent.com/32692807/232279904-27942db7-b8d6-4307-bf21-781f2900a073.png"/>

        만약 부모의 형제가 빨간 색일 경우 ReColoring을 진행하게 됩니다.

        부모와 부모의 형제 모두 검은색으로 바꾸고 그 부모를 빨간색으로 바꿉니다.

        이 경우 Restructuring 보다 조금 까다로운데, 만약 부모가 루트 노드였다면 루트 노드기 때문에 1번의 조건으로 바로 검은색으로 바꾸면 끝이지만, 

        루트 노드가 아닐 경우 ReColoring혹은 Restructuring을 진행해야 합니다. 이 경우 최악의 경우 루트 노드까지 올라가게 됩니다.

<img src="https://user-images.githubusercontent.com/32692807/232280069-465e44aa-5eca-4eda-9bed-e0a86258ed64.png"/>
    </div>
        
</details>

## Q. B-tree
<details>
    <summary>B-tree란?</summary>
    <div>
    

    다중 키를 가지는 데이터베이스와 같은 대규모 데이터를 다룰 때 사용되는 트리 자료구조입니다. 노드의 자식 수가 일정하게 유지되도록 설계되어 있어, 검색, 삽입, 삭제 등의 작업이 빠르게 처리됩니다. B-Tree의 특징은 다음과 같습니다.

- 모든 리프 노드가 동일한 레벨에 위치합니다.
- 각 노드는 최소한 M/2개, 최대 M개의 자식을 가집니다. (M은 정해진 숫자로 노드의 최대 자식 수를 의미합니다)
- 각 노드는 M/2 - 1개, 최대 M-1개의 키를 가집니다.
- B-Tree는 키 값이 중복될 수 있습니다.

시간 복잡도 :
|| B-tree|
|------|---|
|insertion|$O(log n)$|
|deletion|$O(log n)$|
|search|$O(n)$|



- B-Tree의 경우, 탐색, 삽입, 삭제 모두 O(log n)의 시간 복잡도를 가집니다. 따라서 B-Tree는 매우 큰 데이터셋에서도 일관된 성능을 보장할 수 있는 자료구조입니다. 하지만, 노드의 크기가 작아질수록 (즉, B-Tree의 차수가 작아질수록) 성능이 저하될 수 있습니다.
    </div>

</details>

--- 

## Q. B+tree
<details>
    <summary>B+tree란 ?</summary>
    <div>

    다중 키를 가지는 데이터베이스와 같은 대규모 데이터를 다룰 때 사용되는 트리 자료구조입니다. 노드의 자식 수가 일정하게 유지되도록 설계되어 있어, 검색, 삽입, 삭제 등의 작업이 빠르게 처리됩니다. B-Tree의 특징은 다음과 같습니다.

- 모든 리프 노드가 동일한 레벨에 위치합니다.
- 각 노드는 최소한 M/2개, 최대 M개의 자식을 가집니다. (M은 정해진 숫자로 노드의 최대 자식 수를 의미합니다)
- 각 노드는 M/2 - 1개, 최대 M-1개의 키를 가집니다.
- B-Tree는 키 값이 중복될 수 있습니다.

시간 복잡도 :
|| B+tree|
|------|---|
|insertion|$O(log n)$|
|deletion|$O(log n)$|
|search|$O(n)$|

- B-Tree의 경우, 탐색, 삽입, 삭제 모두 O(log n)의 시간 복잡도를 가집니다. 따라서 B-Tree는 매우 큰 데이터셋에서도 일관된 성능을 보장할 수 있는 자료구조입니다. 하지만, 노드의 크기가 작아질수록 (즉, B-Tree의 차수가 작아질수록) 성능이 저하될 수 있습니다.
    </div>
</details> 


## Q. 그럼 모든 상황에서 B+tree가 더 좋은 거 아냐 ?
<details>
    <summary>답변</summary>
    <div>

    B+Tree가 항상 B-Tree보다 더 나은 것은 아닙니다.

    B+Tree는 내부 노드에는 실제 데이터가 저장되지 않고, 리프 노드에서만 데이터가 저장되므로, 범위 검색과 같은 연산에서는 B+Tree가 더 빠른 속도를 보일 수 있습니다. 하지만, B-Tree는 내부 노드에 데이터가 저장되므로, 특정 키 값에 해당하는 데이터를 찾는 연산에서는 B-Tree가 더 빠른 속도를 보일 수 있습니다.

    또한, B+Tree는 더 많은 리프 노드를 가지기 때문에, B-Tree보다 더 많은 메모리를 사용합니다. 따라서, 메모리 용량이 제한적인 환경에서는 B-Tree가 더 적합할 수 있습니다.

    따라서, 어떤 자료구조를 사용할지는 사용하는 상황에 따라 달라질 수 있으며, 어떤 자료구조가 더 좋은지는 상황에 따라 다릅니다.
</div>
</details>